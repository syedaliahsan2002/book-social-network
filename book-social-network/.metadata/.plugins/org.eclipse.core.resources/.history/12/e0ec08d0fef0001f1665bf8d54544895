package com.ali.book.book;


import java.util.List;
import java.util.Objects;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import com.ali.book.common.PageResponse;
import com.ali.book.exception.OperationNotPremittedException;
import com.ali.book.file.FileStorageService;
import com.ali.book.history.BookTransactionHistory;
import com.ali.book.history.BookTransactionHistoryRepository;
import com.ali.book.user.User;

import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;


@Service
@RequiredArgsConstructor

public class BookService {

	private final BookRepository bookRepository;
	private final BookMapper bookMapper;
	private final BookTransactionHistoryRepository transactionHistoryRepository;
	private final FileStorageService fileStorageService;
	
	public Integer save(BookRequest request, Authentication connectedUser) {
	//	User user = ((User) connectedUser.getPrincipal());
		Book book = bookMapper.toBook(request);
		//book.setOwner(user);

		return bookRepository.save(book).getId();
	}
	
	public BookResponse findById(Integer bookId) {
		return bookRepository.findById(bookId)
				.map(bookMapper::toBookResponse)
				.orElseThrow(() -> new EntityNotFoundException("No Book found with the Id:: " + bookId));
	}

	public PageResponse<BookResponse> findAllBooks(int page, int size, Authentication connectedUser) {
		// TODO Auto-generated method stub
		//User user = ((User) connectedUser.getPrincipal());
		Pageable pageable = PageRequest.of(page, size, Sort.by("createdDate").descending());
		Page<Book> books =bookRepository.findAllDisplayableBooks(pageable, connectedUser.getName());
		List<BookResponse> bookResponse = books.stream()
				.map(bookMapper::toBookResponse)
				.toList();
		return new PageResponse<>(
				bookResponse,
				books.getNumber(),
				books.getSize(),
				books.getTotalElements(),
				books.getTotalPages(),
				books.isFirst(),
				books.isLast()
				);
	}

	public PageResponse<BookResponse> findAllBooksbyOwner(int page, int size, Authentication connectedUser) {
		// TODO Auto-generated method stub
		User user = ((User) connectedUser.getPrincipal());
		Pageable pageable = PageRequest.of(page, size, Sort.by("createdDate").descending());
		Page<Book> books =bookRepository.findAll(BookSpecification.withOwnerId(user.getId()), pageable);
		List<BookResponse> bookResponse = books.stream()
				.map(bookMapper::toBookResponse)
				.toList();
		return new PageResponse<>(
				bookResponse,
				books.getNumber(),
				books.getSize(),
				books.getTotalElements(),
				books.getTotalPages(),
				books.isFirst(),
				books.isLast()
				);
	}

	public PageResponse<BorrowedBookResponse> findAllBorrowedBooks(int page, int size, Authentication connectedUser) {
		// TODO Auto-generated method stub
	//	User user = ((User) connectedUser.getPrincipal());
		Pageable pageable = PageRequest.of(page, size, Sort.by("createdDate").descending());
		Page<BookTransactionHistory> allBorrowedBooks = transactionHistoryRepository.findAllBorrowedBooks(pageable,connectedUser.getName());
		List<BorrowedBookResponse> bookResponse = allBorrowedBooks.stream()
				.map(bookMapper::toBorrowedBookResponse)
				.toList();
		return new PageResponse<>(
				bookResponse,
				allBorrowedBooks.getNumber(),
				allBorrowedBooks.getSize(),
				allBorrowedBooks.getTotalElements(),
				allBorrowedBooks.getTotalPages(),
				allBorrowedBooks.isFirst(),
				allBorrowedBooks.isLast()
				);
	}

	public  PageResponse<BorrowedBookResponse> findAllReturnedBooks(int page, int size, Authentication connectedUser) {
		// TODO Auto-generated method stub
	//	User user = ((User) connectedUser.getPrincipal());
		Pageable pageable = PageRequest.of(page, size, Sort.by("createdDate").descending());
		Page<BookTransactionHistory> allBorrowedBooks = transactionHistoryRepository.findAllReturnedBooks(pageable, connectedUser.getName());
		List<BorrowedBookResponse> bookResponse = allBorrowedBooks.stream()
				.map(bookMapper::toBorrowedBookResponse)
				.toList();
		return new PageResponse<>(
				bookResponse,
				allBorrowedBooks.getNumber(),
				allBorrowedBooks.getSize(),
				allBorrowedBooks.getTotalElements(),
				allBorrowedBooks.getTotalPages(),
				allBorrowedBooks.isFirst(),
				allBorrowedBooks.isLast()
				);
	}

	public Integer updateShareableStatus(Integer bookId, Authentication connectedUser) {
		// TODO Auto-generated method stub
		Book book = bookRepository.findById(bookId)
				.orElseThrow(() -> new EntityNotFoundException("No book found with id ::" + bookId));
		//User user = ((User) connectedUser.getPrincipal());
		if(!Objects.equals(book.getCreatedBy(), connectedUser.getName())) {
			throw new OperationNotPremittedException("you can not update others books shareable status");
		}
		book.setShareable(!book.isShareable());
		bookRepository.save(book);
		return bookId;
	}

	public Integer updateArchivedStatus(Integer bookId, Authentication connectedUser) {
		// TODO Auto-generated method stub
		Book book = bookRepository.findById(bookId)
				.orElseThrow(() -> new EntityNotFoundException("No book found with id ::" + bookId));
	//	User user = ((User) connectedUser.getPrincipal());
		if(!Objects.equals(book.getCreatedBy(), connectedUser.getName())) {
			throw new OperationNotPremittedException("you can not update others books archived status");
		}
		book.setArchived(!book.isArchived());
		bookRepository.save(book);
		return bookId;
	}

	public Integer borrowBook(Integer bookId, Authentication connectedUser) {
		// TODO Auto-generated method stub
		Book book = bookRepository.findById(bookId)
				.orElseThrow(() -> new EntityNotFoundException("No book found with id ::" + bookId));
		if(book.isArchived()|| !book.isShareable()) {
			throw new OperationNotPremittedException("The requested book cannot be borrowed since it is archived or not shareable");
		}
		//User user = ((User) connectedUser.getPrincipal());
		if(Objects.equals(book.getCreatedBy(), connectedUser.getName())) {
			throw new OperationNotPremittedException("you can not borrowed your own book");
		}
		final boolean isAlreadyBorrowed = transactionHistoryRepository.isAlreadyBorrowedByUser(bookId,connectedUser.getName());
		if(isAlreadyBorrowed) {
			throw new OperationNotPremittedException("the requested book is already borrowed");
		}
		BookTransactionHistory bookTransactionHistory = BookTransactionHistory.builder()
				.userId(connectedUser.getName())
				.book(book)
				.returned(false)
				.returnApproved(false)
				.build();
		return transactionHistoryRepository.save(bookTransactionHistory).getId();
	}

	public Integer returnBorrowedBook(Integer bookId, Authentication connectedUser) {
		// TODO Auto-generated method stub
		Book book = bookRepository.findById(bookId)
				.orElseThrow(() -> new EntityNotFoundException("No book found with id ::" + bookId));
		if(book.isArchived()|| !book.isShareable()) {
			throw new OperationNotPremittedException("The requested book cannot be borrowed since it is archived or not shareable");
		}
		//User user = ((User) connectedUser.getPrincipal());
		if(Objects.equals(book.getCreatedBy(), connectedUser.getName())) {
			throw new OperationNotPremittedException("you can not borrowed or return your own book");
		}
		BookTransactionHistory bookTransactionHistory = transactionHistoryRepository.findByBookIdAndUserId(bookId, connectedUser.getName())
				.orElseThrow(() -> new OperationNotPremittedException("You did Not borrow this book"));
		bookTransactionHistory.setReturned(true);
		
		
		return transactionHistoryRepository.save(bookTransactionHistory).getId();
	}

	public Integer approveReturnBorrowedBook(Integer bookId, Authentication connectedUser) {
		// TODO Auto-generated method stub
		Book book = bookRepository.findById(bookId)
				.orElseThrow(() -> new EntityNotFoundException("No book found with id ::" + bookId));
		if(book.isArchived()|| !book.isShareable()) {
			throw new OperationNotPremittedException("The requested book cannot be borrowed since it is archived or not shareable");
		}
		//User user = ((User) connectedUser.getPrincipal());
		if(!Objects.equals(book.getCreatedBy(), connectedUser.getName())) {
			throw new OperationNotPremittedException("you can not  return your own book");
		}
		BookTransactionHistory bookTransactionHistory = transactionHistoryRepository.findByBookIdAndOwnerId(bookId,connectedUser.getName())
				.orElseThrow(() -> new OperationNotPremittedException("The book is not returned yet. so you can not approve its return"));
		bookTransactionHistory.setReturnApproved(true);
		return transactionHistoryRepository.save(bookTransactionHistory).getId();
	}

	public void uploadBookCoverPicture(MultipartFile file, Authentication connectedUser, Integer bookId) {
		// TODO Auto-generated method stub
		Book book = bookRepository.findById(bookId)
				.orElseThrow(() -> new EntityNotFoundException("No book found with id ::" + bookId));
		//User user = ((User) connectedUser.getPrincipal());
		var bookCover = fileStorageService.saveFile(file, connectedUser.getName());
		book.setBookCover(bookCover);
		bookRepository.save(book);
	
	}

	
}
